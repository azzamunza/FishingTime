<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fishing Time - Best Times to Fish</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.85em;
            color: #666;
            font-weight: bold;
        }
        
        .control-group input, .control-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            width: 150px;
            transition: border-color 0.3s;
        }
        
        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .search-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .search-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
            transition: color 0.3s;
        }
        
        .close-btn:hover {
            color: #333;
        }
        
        .search-input-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1em;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .search-results {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: white;
        }
        
        .search-results li {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }
        
        .search-results li:last-child {
            border-bottom: none;
        }
        
        .search-results li:hover {
            background: #f5f5f5;
        }
        
        .recent-section {
            margin-top: 20px;
        }
        
        .recent-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
        }
        
        .recent-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .recent-list li {
            padding: 10px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }
        
        .recent-list li:hover {
            background: #f5f5f5;
            border-color: #667eea;
        }
        
        .no-results {
            text-align: center;
            color: #999;
            padding: 20px;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .chart-section {
            flex: 1;
            min-width: 600px;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .controls-panel {
            width: 350px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-height: 800px;
            overflow-y: auto;
        }
        
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .controls-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }
        
        .controls-panel::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 10px;
        }
        
        .viz-title {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }
        
        .viz-subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1em;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .dataset-control {
            background: #f5f7fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .dataset-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .dataset-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .dataset-header label {
            font-weight: bold;
            color: #333;
            cursor: pointer;
            flex: 1;
        }
        
        .range-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .range-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        
        .range-label {
            font-size: 0.85em;
            color: #666;
            min-width: 80px;
        }
        
        .range-input {
            flex: 1;
            height: 6px;
        }
        
        .range-value {
            font-size: 0.85em;
            color: #667eea;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        .info-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
            text-align: center;
        }
        
        .info-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .info-text {
            color: #555;
            font-size: 0.95em;
            line-height: 1.6;
        }
        
        .day-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .day-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .day-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .day-btn.active {
            background: white;
            color: #667eea;
            transform: scale(1.05);
        }
        
        .tab-menu {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .tab-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }
        
        .tab-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .chart-container {
            display: none;
        }
        
        .chart-container.active {
            display: block;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-color {
            width: 25px;
            height: 25px;
            border-radius: 4px;
        }
        
        .controls-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            
            .chart-section {
                min-width: 100%;
            }
            
            .controls-panel {
                width: 100%;
                max-height: none;
            }
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.2em;
        }
        
        .error {
            background: #ffebee;
            border: 2px solid #ef5350;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            color: #c62828;
            text-align: center;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .data-timeline {
            margin-top: 40px;
            padding: 25px;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .timeline-title {
            text-align: center;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2em;
        }
        
        .timeline-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
            overflow-x: auto;
            padding: 10px 0;
        }
        
        .timeline-item {
            flex: 1;
            min-width: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 10px 5px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transition: transform 0.2s;
        }
        
        .timeline-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .timeline-time {
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
            width: 100%;
        }
        
        .timeline-data-item {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin: 4px 0;
            font-size: 0.85em;
            color: #555;
            font-weight: 500;
        }
        
        .timeline-data-item .icon {
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé£ Fishing Time</h1>
        
        <div class="controls-section">
            <div class="control-group">
                <label for="latitude">Latitude</label>
                <input type="text" id="latitude" value="-32.055" />
            </div>
            <div class="control-group">
                <label for="longitude">Longitude</label>
                <input type="text" id="longitude" value="115.745" />
            </div>
            <button class="search-btn" id="locationSearchBtn">
                <span>üîç</span>
                <span>Location Search</span>
            </button>
            <div class="control-group">
                <label for="timezoneSelect">Timezone</label>
                <select id="timezoneSelect">
                    <option value="Australia/Perth" selected>Australia/Perth</option>
                    <option value="UTC">UTC</option>
                    <option value="Australia/Adelaide">Australia/Adelaide</option>
                    <option value="Australia/Sydney">Australia/Sydney</option>
                    <option value="Australia/Brisbane">Australia/Brisbane</option>
                    <option value="Australia/Darwin">Australia/Darwin</option>
                    <option value="Australia/Hobart">Australia/Hobart</option>
                    <option value="Asia/Singapore">Asia/Singapore</option>
                    <option value="Asia/Tokyo">Asia/Tokyo</option>
                    <option value="Europe/London">Europe/London</option>
                    <option value="Europe/Berlin">Europe/Berlin</option>
                    <option value="America/New_York">America/New_York</option>
                    <option value="America/Los_Angeles">America/Los_Angeles</option>
                </select>
            </div>
            <button class="search-btn" id="fetchDataBtn">üé£ Get Fishing Conditions</button>
        </div>
        
        <div class="modal-overlay" id="locationModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Search Location</h2>
                    <button class="close-btn" id="closeModal">&times;</button>
                </div>
                <div class="search-input-container">
                    <input type="text" id="locationSearchInput" class="search-input" placeholder="Search for a location..." autocomplete="off" />
                </div>
                <ul id="searchResults" class="search-results" style="display: none;"></ul>
                <div class="recent-section">
                    <h3 class="recent-title">Recent Locations</h3>
                    <ul id="recentLocations" class="recent-list"></ul>
                </div>
            </div>
        </div>
        
        <div class="day-selector" id="daySelector"></div>
        
        <div class="controls-row">
            <button class="day-btn" id="weeklyOverviewBtn">Weekly Overview</button>
        </div>
        
        <div class="main-content">
            <div class="chart-section">
                <h2 class="viz-title" id="locationTitle">Loading...</h2>
                <p class="viz-subtitle" id="dateSubtitle">Select a location to view fishing conditions</p>
                
                <div class="tab-menu" id="chartTabMenu">
                    <button class="tab-btn active" data-chart="separated">Separated Rings</button>
                    <button class="tab-btn" data-chart="overlaid">Overlaid</button>
                    <button class="tab-btn" data-chart="stacked">Stacked</button>
                    <button class="tab-btn" data-chart="hourlyRating">Hourly Rating</button>
                    <button class="tab-btn" data-chart="circular">24-Hour Circular</button>
                    <button class="tab-btn" data-chart="rating">Hourly Rating (Bar)</button>
                </div>
                
                <div class="chart-container active" id="separatedChartContainer">
                    <div class="canvas-container">
                        <canvas id="separatedCanvas" width="1000" height="600" aria-label="Separated rings chart"></canvas>
                    </div>
                    
                    <div class="data-timeline">
                        <div class="timeline-title">Hourly Data</div>
                        <div class="timeline-container" id="timeline1"></div>
                    </div>
                    
                    <div class="legend" id="legend1"></div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart shows each enabled dataset in its own ring. Each ring represents a different metric 
                            with its own scale. The chart flows clockwise with time, using filled spline areas to show 
                            the values throughout the day.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="overlaidChartContainer">
                    <div class="canvas-container">
                        <canvas id="overlaidCanvas" width="1000" height="600" aria-label="Overlaid chart"></canvas>
                    </div>
                    
                    <div class="data-timeline">
                        <div class="timeline-title">Hourly Data</div>
                        <div class="timeline-container" id="timeline2"></div>
                    </div>
                    
                    <div class="legend" id="legend2"></div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart overlays all enabled datasets in the same normalized 0-1 range, making it easy 
                            to compare different metrics directly. All values are normalized to their ideal ranges.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="stackedChartContainer">
                    <div class="canvas-container">
                        <canvas id="stackedCanvas" width="1000" height="600" aria-label="Stacked chart"></canvas>
                    </div>
                    
                    <div class="data-timeline">
                        <div class="timeline-title">Hourly Data</div>
                        <div class="timeline-container" id="timeline3"></div>
                    </div>
                    
                    <div class="legend" id="legend3"></div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart stacks all enabled datasets on top of each other with special normalization. 
                            Each value is divided by the number of datasets, so the maximum stacked height is always 1.0. 
                            This allows for consistent visualization regardless of how many datasets are enabled.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="hourlyRatingChartContainer">
                    <div class="canvas-container">
                        <canvas id="hourlyRatingCanvas" width="1000" height="600" aria-label="Hourly rating chart"></canvas>
                    </div>
                    
                    <div class="legend" id="legend4"></div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart shows the combined fishing rating for each hour, calculated from all enabled 
                            datasets. The rating uses normalized values and shows the overall fishing conditions throughout the day.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="circularChartContainer">
                    <div class="canvas-container">
                        <canvas id="mainCanvas" width="600" height="600" aria-label="24-hour circular fishing forecast chart showing optimal fishing times throughout the day"></canvas>
                    </div>
                    
                    <div class="legend" id="legend"></div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This 24-hour circular chart shows the best fishing times throughout the day. 
                            The chart is oriented with 12:00 noon at the top and 12:00 midnight at the bottom.
                            6:00 AM is on the left, and 6:00 PM is on the right.
                            Brighter/fuller areas indicate better fishing conditions based on your selected criteria.
                            Each dataset (tide, wind, temperature, etc.) can be enabled/disabled and customized using the controls panel.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="ratingChartContainer">
                    <div class="canvas-container">
                        <canvas id="ratingCanvas" width="600" height="400" aria-label="Hourly fishing rating bar chart"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                            <span><strong>Overall Fishing Rating</strong> (0-100%)</span>
                        </div>
                    </div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart shows the overall fishing rating for each hour of the day.
                            Higher bars indicate better fishing conditions. The rating combines all enabled datasets
                            into a single score, with values closer to the ideal ranges producing higher scores.
                        </div>
                    </div>
                </div>
                
                <div class="chart-container" id="weeklyChartContainer">
                    <div class="canvas-container">
                        <canvas id="weeklyCanvas" width="700" height="400" aria-label="Weekly fishing overview chart"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                            <span><strong>Daily Average Rating</strong> (0-100%)</span>
                        </div>
                    </div>
                    
                    <div class="info-box">
                        <div class="info-title">How to Read This Chart</div>
                        <div class="info-text">
                            This chart displays the average fishing rating for each day of the week.
                            Each bar represents the average of all hourly ratings for that day.
                            Higher values indicate better overall fishing conditions for that day.
                            Click on any day button above to view detailed hourly charts.
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <h3 class="controls-title">Dataset Controls</h3>
                <div id="datasetControls"></div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as TideHarmonic from './tide-harmonic.js';
        
        // Configuration constants
        const FORECAST_DAYS = 7;  // Number of days to fetch from API
        const HOUR_LABEL_INTERVAL = 3;  // Show hour labels every N hours
        const AREA_OPACITY = '80';  // 50% opacity for filled areas (hex value)
        
        // Chart layout constants
        const CHART_PADDING = {
            side: 80,
            top: 70,
            bottom: 20
        };
        
        // Color gradient constants for chart visualization
        const CHART_COLORS = {
            // RGB gradient from low to high score (purple-blue to violet)
            RGB_LOW_R: 102,    // Red component for low scores
            RGB_HIGH_R: 118,   // Red component for high scores
            RGB_LOW_G: 126,    // Green component for low scores
            RGB_HIGH_G: 75,    // Green component for high scores
            RGB_LOW_B: 234,    // Blue component for low scores
            RGB_HIGH_B: 162,   // Blue component for high scores
            ALPHA_MIN: 0.7,    // Minimum alpha transparency
            ALPHA_RANGE: 0.3   // Additional alpha for high scores
        };
        
        // Global state
        let weatherData = null;
        let marineData = null;
        let tideStation = null;
        let currentLocation = { name: 'Fremantle', lat: -32.055, lon: 115.745 };
        let currentTimezone = 'Australia/Perth';
        let currentDay = 0;  // Currently selected day (0-6)
        let allDaysData = [];  // Store parsed data for all 7 days
        let searchController;  // For aborting previous search requests
        
        // Dataset configurations
        const datasets = {
            tideHeight: {
                name: 'Tide Height',
                enabled: true,
                color: '#1976d2',
                min: -2,
                max: 2,
                idealMin: -0.5,
                idealMax: 0.5,
                unit: 'm'
            },
            tideMovement: {
                name: 'Tide Movement',
                enabled: true,
                color: '#0288d1',
                min: -1,
                max: 1,
                idealMin: 0.2,
                idealMax: 0.8,
                unit: 'm/h'
            },
            windSpeed: {
                name: 'Wind Speed',
                enabled: true,
                color: '#32dbae',
                min: 0,
                max: 30,
                idealMin: 0,
                idealMax: 15,
                unit: 'km/h'
            },
            temperature: {
                name: 'Temperature',
                enabled: true,
                color: '#F28C28',
                min: 10,
                max: 40,
                idealMin: 18,
                idealMax: 28,
                unit: '¬∞C'
            },
            cloudCover: {
                name: 'Cloud Cover',
                enabled: true,
                color: '#c1cad9',
                min: 0,
                max: 100,
                idealMin: 0,
                idealMax: 60,
                unit: '%'
            },
            pressure: {
                name: 'Pressure',
                enabled: true,
                color: '#9c27b0',
                min: 990,
                max: 1030,
                idealMin: 1010,
                idealMax: 1020,
                unit: 'hPa'
            },
            waveHeight: {
                name: 'Wave Height',
                enabled: true,
                color: '#2196f3',
                min: 0,
                max: 3,
                idealMin: 0,
                idealMax: 1,
                unit: 'm'
            }
        };
        
        // Initialize
        async function init() {
            try {
                await TideHarmonic.loadStations('./stations.json');
                console.log('Tide stations loaded successfully');
                renderDatasetControls();
                attachEventListeners();
            } catch (error) {
                console.error('Failed to initialize:', error);
                showError('Failed to load tide station data');
            }
        }
        
        function attachEventListeners() {
            document.getElementById('fetchDataBtn').addEventListener('click', fetchData);
            document.getElementById('locationSearchBtn').addEventListener('click', openLocationModal);
            document.getElementById('closeModal').addEventListener('click', closeLocationModal);
            document.getElementById('locationModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('locationModal')) {
                    closeLocationModal();
                }
            });
            document.getElementById('locationSearchInput').addEventListener('input', handleLocationSearch);
            
            // Chart tab switching
            document.getElementById('chartTabMenu').addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-btn')) {
                    // Update active tab button
                    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Show corresponding chart
                    const chartType = e.target.getAttribute('data-chart');
                    document.querySelectorAll('.chart-container').forEach(container => container.classList.remove('active'));
                    
                    if (chartType === 'separated') {
                        document.getElementById('separatedChartContainer').classList.add('active');
                    } else if (chartType === 'overlaid') {
                        document.getElementById('overlaidChartContainer').classList.add('active');
                    } else if (chartType === 'stacked') {
                        document.getElementById('stackedChartContainer').classList.add('active');
                    } else if (chartType === 'hourlyRating') {
                        document.getElementById('hourlyRatingChartContainer').classList.add('active');
                    } else if (chartType === 'circular') {
                        document.getElementById('circularChartContainer').classList.add('active');
                    } else if (chartType === 'rating') {
                        document.getElementById('ratingChartContainer').classList.add('active');
                    } else if (chartType === 'weekly') {
                        document.getElementById('weeklyChartContainer').classList.add('active');
                    }
                    
                    updateChart();
                }
            });
            
            // Weekly overview button handler
            document.getElementById('weeklyOverviewBtn').addEventListener('click', () => {
                // Hide chart tab menu
                document.getElementById('chartTabMenu').style.display = 'none';
                
                // Update active tab button states
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('weeklyOverviewBtn').classList.add('active');
                
                // Hide all daily charts, show weekly
                document.querySelectorAll('.chart-container').forEach(container => container.classList.remove('active'));
                document.getElementById('weeklyChartContainer').classList.add('active');
                
                // Remove active state from day selector buttons
                document.querySelectorAll('#daySelector .day-btn').forEach(btn => btn.classList.remove('active'));
                
                drawWeeklyChart();
            });
        }
        
        function renderDatasetControls() {
            const container = document.getElementById('datasetControls');
            container.innerHTML = '';
            
            for (const [key, dataset] of Object.entries(datasets)) {
                const control = createDatasetControl(key, dataset);
                container.appendChild(control);
            }
        }
        
        function createDatasetControl(key, dataset) {
            const div = document.createElement('div');
            div.className = 'dataset-control';
            
            div.innerHTML = `
                <div class="dataset-header">
                    <input type="checkbox" id="enable_${key}" ${dataset.enabled ? 'checked' : ''}>
                    <label for="enable_${key}">${dataset.name}</label>
                </div>
                <div class="range-control">
                    <div class="range-row">
                        <span class="range-label">Min</span>
                        <input type="range" class="range-input" id="min_${key}" 
                               min="${dataset.min}" max="${dataset.max}" 
                               value="${dataset.min}" step="0.1">
                        <span class="range-value" id="minval_${key}">${dataset.min}${dataset.unit}</span>
                    </div>
                    <div class="range-row">
                        <span class="range-label">Ideal Min</span>
                        <input type="range" class="range-input" id="idealmin_${key}" 
                               min="${dataset.min}" max="${dataset.max}" 
                               value="${dataset.idealMin}" step="0.1">
                        <span class="range-value" id="idealminval_${key}">${dataset.idealMin}${dataset.unit}</span>
                    </div>
                    <div class="range-row">
                        <span class="range-label">Ideal Max</span>
                        <input type="range" class="range-input" id="idealmax_${key}" 
                               min="${dataset.min}" max="${dataset.max}" 
                               value="${dataset.idealMax}" step="0.1">
                        <span class="range-value" id="idealmaxval_${key}">${dataset.idealMax}${dataset.unit}</span>
                    </div>
                    <div class="range-row">
                        <span class="range-label">Max</span>
                        <input type="range" class="range-input" id="max_${key}" 
                               min="${dataset.min}" max="${dataset.max}" 
                               value="${dataset.max}" step="0.1">
                        <span class="range-value" id="maxval_${key}">${dataset.max}${dataset.unit}</span>
                    </div>
                </div>
            `;
            
            // Attach event listeners
            const checkbox = div.querySelector(`#enable_${key}`);
            checkbox.addEventListener('change', (e) => {
                dataset.enabled = e.target.checked;
                updateChart();
            });
            
            const sliders = ['min', 'idealmin', 'idealmax', 'max'];
            sliders.forEach(slider => {
                const input = div.querySelector(`#${slider}_${key}`);
                const valueSpan = div.querySelector(`#${slider}val_${key}`);
                
                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueSpan.textContent = `${value}${dataset.unit}`;
                    
                    if (slider === 'min') dataset.min = value;
                    else if (slider === 'idealmin') dataset.idealMin = value;
                    else if (slider === 'idealmax') dataset.idealMax = value;
                    else if (slider === 'max') dataset.max = value;
                    
                    updateChart();
                });
            });
            
            return div;
        }
        
        async function fetchData() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            const timezone = document.getElementById('timezoneSelect').value;
            
            if (isNaN(lat) || isNaN(lon)) {
                showError('Invalid latitude or longitude');
                return;
            }
            
            currentLocation = { lat, lon, name: `${lat.toFixed(2)}, ${lon.toFixed(2)}` };
            currentTimezone = timezone;
            
            document.getElementById('locationTitle').textContent = 'Loading...';
            document.getElementById('dateSubtitle').textContent = 'Fetching data...';
            
            try {
                // Fetch weather data for configured number of days
                const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,wind_speed_10m,wind_direction_10m,cloud_cover,surface_pressure,pressure_msl,precipitation_probability,rain,relative_humidity_2m,apparent_temperature&timezone=${timezone}&forecast_days=${FORECAST_DAYS}`;
                const weatherResponse = await fetch(weatherUrl);
                weatherData = await weatherResponse.json();
                
                // Fetch marine data for configured number of days
                const marineUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,sea_surface_temperature,wave_direction,wave_period,tertiary_swell_wave_height,tertiary_swell_wave_period,tertiary_swell_wave_direction&timezone=${timezone}&forecast_days=${FORECAST_DAYS}`;
                const marineResponse = await fetch(marineUrl);
                marineData = await marineResponse.json();
                
                // Find nearest tide station
                tideStation = TideHarmonic.findNearestStation(lat, lon);
                
                // Parse data into daily chunks
                parseDailyData();
                
                // Create day selector buttons
                createDaySelector();
                
                // Update charts
                updateChart();
                updateLegend();
            } catch (error) {
                console.error('Error fetching data:', error);
                showError('Failed to fetch weather or marine data');
            }
        }
        
        function parseDailyData() {
            allDaysData = [];
            
            if (!weatherData || !weatherData.hourly || !weatherData.hourly.time) {
                return;
            }
            
            const times = weatherData.hourly.time;
            const totalHours = times.length;
            
            // Group data by days (24 hours each)
            for (let dayIndex = 0; dayIndex < FORECAST_DAYS && dayIndex * 24 < totalHours; dayIndex++) {
                const startHour = dayIndex * 24;
                const endHour = Math.min(startHour + 24, totalHours);
                
                const dayData = {
                    date: times[startHour].split('T')[0],
                    hours: []
                };
                
                for (let hour = startHour; hour < endHour; hour++) {
                    dayData.hours.push(hour);
                }
                
                allDaysData.push(dayData);
            }
        }
        
        function createDaySelector() {
            const selector = document.getElementById('daySelector');
            selector.innerHTML = '';
            
            allDaysData.forEach((dayData, index) => {
                const btn = document.createElement('button');
                btn.className = 'day-btn' + (index === 0 ? ' active' : '');
                
                const date = new Date(dayData.date + 'T00:00:00');
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                btn.textContent = dayName;
                btn.setAttribute('data-day', index);
                
                btn.addEventListener('click', () => {
                    currentDay = index;
                    document.querySelectorAll('.day-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Show chart tab menu if coming from weekly view
                    document.getElementById('chartTabMenu').style.display = 'flex';
                    document.getElementById('weeklyOverviewBtn').classList.remove('active');
                    
                    // Switch to separated rings chart if on weekly view or no active tab
                    const activeTab = document.querySelector('.tab-btn.active');
                    if (!activeTab || activeTab.getAttribute('data-chart') === 'weekly') {
                        document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
                        document.querySelector('.tab-btn[data-chart="separated"]').classList.add('active');
                        document.querySelectorAll('.chart-container').forEach(c => c.classList.remove('active'));
                        document.getElementById('separatedChartContainer').classList.add('active');
                    }
                    
                    updateChart();
                });
                
                selector.appendChild(btn);
            });
        }
        
        function updateChart() {
            if (!weatherData || !marineData || allDaysData.length === 0) {
                return;
            }
            
            const activeTab = document.querySelector('.tab-btn.active');
            const chartType = activeTab ? activeTab.getAttribute('data-chart') : 'separated';
            
            if (chartType === 'separated') {
                drawSeparatedChartForDay(currentDay);
            } else if (chartType === 'overlaid') {
                drawOverlaidChartForDay(currentDay);
            } else if (chartType === 'stacked') {
                drawStackedChartForDay(currentDay);
            } else if (chartType === 'hourlyRating') {
                drawHourlyRatingChartForDay(currentDay);
            } else if (chartType === 'circular') {
                drawCircularChartForDay(currentDay);
            } else if (chartType === 'rating') {
                drawRatingChartForDay(currentDay);
            } else if (chartType === 'weekly') {
                drawWeeklyChart();
            }
        }
        
        function drawCircularChartForDay(dayIndex) {
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 60;
            
            ctx.clearRect(0, 0, width, height);
            
            if (dayIndex >= allDaysData.length) return;
            
            const dayData = allDaysData[dayIndex];
            const scores = [];
            
            // Calculate scores for each hour of the day
            for (let hourOffset = 0; hourOffset < dayData.hours.length; hourOffset++) {
                const hourIndex = dayData.hours[hourOffset];
                const score = calculateFishingScoreForHour(hourIndex);
                scores.push({ hour: hourOffset, score, hourIndex });
            }
            
            // Draw the circular chart
            drawCircularChart(ctx, centerX, centerY, radius, scores);
            
            // Update location title
            const date = new Date(dayData.date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Fishing Conditions`;
        }
        
        function drawRatingChartForDay(dayIndex) {
            const canvas = document.getElementById('ratingCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (dayIndex >= allDaysData.length) return;
            
            const dayData = allDaysData[dayIndex];
            const scores = [];
            
            // Calculate scores for each hour of the day
            for (let hourOffset = 0; hourOffset < dayData.hours.length; hourOffset++) {
                const hourIndex = dayData.hours[hourOffset];
                const score = calculateFishingScoreForHour(hourIndex);
                scores.push({ hour: hourOffset, score });
            }
            
            // Draw bar chart
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / scores.length;
            const barSpacing = barWidth * 0.1;
            const actualBarWidth = barWidth - barSpacing;
            
            // Draw bars
            scores.forEach((item, i) => {
                const barHeight = item.score * chartHeight;
                const x = padding + i * barWidth + barSpacing / 2;
                const y = height - padding - barHeight;
                
                // Gradient for each bar
                const gradient = ctx.createLinearGradient(x, y, x, height - padding);
                gradient.addColorStop(0, '#764ba2');
                gradient.addColorStop(1, '#667eea');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, actualBarWidth, barHeight);
                
                // Bar outline
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, actualBarWidth, barHeight);
                
                // Hour labels at configured intervals
                if (i % HOUR_LABEL_INTERVAL === 0) {
                    ctx.fillStyle = '#333';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${item.hour}:00`, x + actualBarWidth / 2, height - padding + 20);
                }
                
                // Score percentage on top
                if (item.score > 0.1) {
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.round(item.score * 100)}%`, x + actualBarWidth / 2, y - 5);
                }
            });
            
            // Draw baseline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Update title
            const date = new Date(dayData.date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Hourly Ratings`;
        }
        
        function drawWeeklyChart() {
            const canvas = document.getElementById('weeklyCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (allDaysData.length === 0) return;
            
            // Calculate average score for each day
            const dailyAverages = allDaysData.map(dayData => {
                let total = 0;
                let count = 0;
                
                dayData.hours.forEach(hourIndex => {
                    const score = calculateFishingScoreForHour(hourIndex);
                    total += score;
                    count++;
                });
                
                return {
                    date: dayData.date,
                    average: count > 0 ? total / count : 0
                };
            });
            
            // Draw bar chart
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / dailyAverages.length;
            const barSpacing = barWidth * 0.2;
            const actualBarWidth = barWidth - barSpacing;
            
            dailyAverages.forEach((item, i) => {
                const barHeight = item.average * chartHeight;
                const x = padding + i * barWidth + barSpacing / 2;
                const y = height - padding - barHeight;
                
                // Gradient for each bar
                const gradient = ctx.createLinearGradient(x, y, x, height - padding);
                gradient.addColorStop(0, '#764ba2');
                gradient.addColorStop(1, '#667eea');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, actualBarWidth, barHeight);
                
                // Bar outline
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, actualBarWidth, barHeight);
                
                // Date label
                const date = new Date(item.date + 'T00:00:00');
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                ctx.fillStyle = '#333';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(x + actualBarWidth / 2, height - padding + 30);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(dayName, 0, 0);
                ctx.restore();
                
                // Score percentage on top
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(item.average * 100)}%`, x + actualBarWidth / 2, y - 10);
            });
            
            // Draw baseline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Update title
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = '7-Day Fishing Forecast Overview';
        }
        
        function calculateFishingScoreForHour(hourIndex) {
            let totalScore = 0;
            let enabledCount = 0;
            
            // Cache hourly data references
            const weatherHourly = weatherData?.hourly;
            const marineHourly = marineData?.hourly;
            
            // Get the timestamp for tide calculations
            const timeString = weatherHourly?.time?.[hourIndex];
            const time = timeString ? new Date(timeString) : null;
            
            for (const [key, dataset] of Object.entries(datasets)) {
                if (!dataset.enabled) continue;
                
                let value;
                
                try {
                    if (key === 'tideHeight' && tideStation && time) {
                        value = TideHarmonic.predictTideHeight(tideStation, time);
                    } else if (key === 'tideMovement' && tideStation && time) {
                        value = TideHarmonic.calculateTideMovement(tideStation, time);
                    } else if (key === 'windSpeed' && weatherHourly) {
                        value = weatherHourly.wind_speed_10m[hourIndex];
                    } else if (key === 'temperature' && weatherHourly) {
                        value = weatherHourly.temperature_2m[hourIndex];
                    } else if (key === 'cloudCover' && weatherHourly) {
                        value = weatherHourly.cloud_cover[hourIndex];
                    } else if (key === 'pressure' && weatherHourly) {
                        value = weatherHourly.pressure_msl[hourIndex];
                    } else if (key === 'waveHeight' && marineHourly) {
                        value = marineHourly.wave_height[hourIndex];
                    } else {
                        continue;
                    }
                    
                    if (value === null || value === undefined) continue;
                    
                    const score = normalizeScore(value, dataset);
                    totalScore += score;
                    enabledCount++;
                } catch (error) {
                    console.error(`Error calculating ${key}:`, error);
                }
            }
            
            return enabledCount > 0 ? totalScore / enabledCount : 0;
        }
        
        function normalizeScore(value, dataset) {
            const { min, max, idealMin, idealMax } = dataset;
            
            // Value outside acceptable range
            if (value < min || value > max) {
                return 0;
            }
            
            // Value in ideal range
            if (value >= idealMin && value <= idealMax) {
                return 1;
            }
            
            // Value between min and idealMin
            if (value < idealMin) {
                return (value - min) / (idealMin - min);
            }
            
            // Value between idealMax and max
            return 1 - (value - idealMax) / (max - idealMax);
        }
        
        function drawCircularChart(ctx, centerX, centerY, radius, scores) {
            const hours = scores.length;
            
            // Draw background circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw score segments
            for (let i = 0; i < hours; i++) {
                const angle1 = (i / hours) * 2 * Math.PI - Math.PI / 2; // Start at top (12 noon)
                const angle2 = ((i + 1) / hours) * 2 * Math.PI - Math.PI / 2;
                
                const score = scores[i].score;
                const innerRadius = radius * 0.3;
                const outerRadius = radius * (0.3 + 0.7 * score);
                
                // Draw segment
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, angle1, angle2);
                ctx.arc(centerX, centerY, innerRadius, angle2, angle1, true);
                ctx.closePath();
                
                // Use gradient colors matching the rating chart
                const r = Math.round(CHART_COLORS.RGB_LOW_R + score * (CHART_COLORS.RGB_HIGH_R - CHART_COLORS.RGB_LOW_R));
                const g = Math.round(CHART_COLORS.RGB_LOW_G + score * (CHART_COLORS.RGB_HIGH_G - CHART_COLORS.RGB_LOW_G));
                const b = Math.round(CHART_COLORS.RGB_LOW_B + score * (CHART_COLORS.RGB_HIGH_B - CHART_COLORS.RGB_LOW_B));
                const alpha = CHART_COLORS.ALPHA_MIN + score * CHART_COLORS.ALPHA_RANGE;
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw hour markers and labels
            for (let i = 0; i < hours; i++) {
                const angle = (i / hours) * 2 * Math.PI - Math.PI / 2;
                const hour = i;
                
                // Major markers at configured intervals
                if (hour % HOUR_LABEL_INTERVAL === 0) {
                    const x1 = centerX + Math.cos(angle) * (radius - 15);
                    const y1 = centerY + Math.sin(angle) * (radius - 15);
                    const x2 = centerX + Math.cos(angle) * (radius + 5);
                    const y2 = centerY + Math.sin(angle) * (radius + 5);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label
                    const labelX = centerX + Math.cos(angle) * (radius + 30);
                    const labelY = centerY + Math.sin(angle) * (radius + 30);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${hour}:00`, labelX, labelY);
                }
            }
            
            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.3, 0, 2 * Math.PI);
            ctx.fillStyle = '#f5f7fa';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw center text
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('24 Hour', centerX, centerY - 10);
            ctx.fillText('Forecast', centerX, centerY + 10);
        }
        
        function updateLegend() {
            const legendContainer = document.getElementById('legend');
            legendContainer.innerHTML = '';
            
            // For circular chart, show gradient legend that matches the actual colors
            const activeTab = document.querySelector('.tab-btn.active');
            const chartType = activeTab ? activeTab.getAttribute('data-chart') : 'circular';
            
            if (chartType === 'circular') {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: linear-gradient(to right, rgba(102, 126, 234, 0.7), rgba(118, 75, 162, 1));"></div>
                    <span><strong>Fishing Score</strong> (Low ‚Üí High)</span>
                `;
                legendContainer.appendChild(item);
                
                // Add enabled datasets info
                const enabledDatasets = Object.entries(datasets)
                    .filter(([_, dataset]) => dataset.enabled)
                    .map(([_, dataset]) => dataset.name);
                
                if (enabledDatasets.length > 0) {
                    const datasetsInfo = document.createElement('div');
                    datasetsInfo.style.textAlign = 'center';
                    datasetsInfo.style.width = '100%';
                    datasetsInfo.style.marginTop = '10px';
                    datasetsInfo.style.fontSize = '0.85em';
                    datasetsInfo.style.color = '#666';
                    datasetsInfo.innerHTML = `<em>Based on: ${enabledDatasets.join(', ')}</em>`;
                    legendContainer.appendChild(datasetsInfo);
                }
            } else {
                // For other charts, show individual datasets
                for (const [key, dataset] of Object.entries(datasets)) {
                    if (!dataset.enabled) continue;
                    
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${dataset.color};"></div>
                        <span><strong>${dataset.name}</strong></span>
                    `;
                    legendContainer.appendChild(item);
                }
            }
        }
        
        function showError(message) {
            const chartSection = document.querySelector('.chart-section');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            chartSection.insertBefore(errorDiv, chartSection.firstChild);
            
            setTimeout(() => errorDiv.remove(), 5000);
        }
        
        // Location search functions
        function getRecentLocations() {
            const stored = localStorage.getItem('recentFishingLocations');
            return stored ? JSON.parse(stored) : [];
        }
        
        function saveRecentLocation(location) {
            let recent = getRecentLocations();
            // Remove duplicate if exists (with tolerance for floating-point comparison)
            recent = recent.filter(loc => {
                const latDiff = Math.abs(loc.latitude - location.latitude);
                const lonDiff = Math.abs(loc.longitude - location.longitude);
                return !(latDiff < 0.0001 && lonDiff < 0.0001);
            });
            // Add to front
            recent.unshift(location);
            // Keep only last 10
            recent = recent.slice(0, 10);
            localStorage.setItem('recentFishingLocations', JSON.stringify(recent));
            displayRecentLocations();
        }
        
        function displayRecentLocations() {
            const recentList = document.getElementById('recentLocations');
            const recent = getRecentLocations();
            
            if (recent.length === 0) {
                recentList.innerHTML = '<li class="no-results">No recent locations</li>';
                return;
            }
            
            recentList.innerHTML = '';
            recent.forEach(location => {
                const li = document.createElement('li');
                li.textContent = location.name;
                li.addEventListener('click', () => {
                    selectLocation(location);
                });
                recentList.appendChild(li);
            });
        }
        
        function selectLocation(location) {
            document.getElementById('latitude').value = location.latitude;
            document.getElementById('longitude').value = location.longitude;
            
            // Update location name
            currentLocation.name = location.name || `${location.latitude.toFixed(4)}, ${location.longitude.toFixed(4)}`;
            currentLocation.lat = location.latitude;
            currentLocation.lon = location.longitude;
            
            // Update timezone if available
            if (location.timezone) {
                const timezoneSelect = document.getElementById('timezoneSelect');
                // Check if timezone exists in the dropdown
                let optionExists = false;
                for (let i = 0; i < timezoneSelect.options.length; i++) {
                    if (timezoneSelect.options[i].value === location.timezone) {
                        timezoneSelect.value = location.timezone;
                        currentTimezone = location.timezone;
                        optionExists = true;
                        break;
                    }
                }
                
                // If timezone doesn't exist, add it
                if (!optionExists) {
                    const option = document.createElement('option');
                    option.value = location.timezone;
                    option.textContent = location.timezone;
                    timezoneSelect.appendChild(option);
                    timezoneSelect.value = location.timezone;
                    currentTimezone = location.timezone;
                }
            }
            
            closeLocationModal();
            saveRecentLocation(location);
            
            // Automatically fetch data for the new location
            fetchData();
        }
        
        function openLocationModal() {
            document.getElementById('locationModal').classList.add('active');
            displayRecentLocations();
            document.getElementById('locationSearchInput').value = '';
            document.getElementById('searchResults').style.display = 'none';
        }
        
        function closeLocationModal() {
            document.getElementById('locationModal').classList.remove('active');
        }
        
        function handleLocationSearch(e) {
            const query = e.target.value.trim();
            const searchResults = document.getElementById('searchResults');
            
            searchResults.innerHTML = '';
            searchResults.style.display = 'none';
            
            if (query.length < 3) return;
            
            // Cancel previous request if still running
            if (searchController) searchController.abort();
            searchController = new AbortController();
            
            const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5`;
            
            fetch(url, { signal: searchController.signal })
                .then(response => {
                    if (!response.ok) throw new Error('Failed to fetch location data');
                    return response.json();
                })
                .then(data => {
                    if (!data.results || data.results.length === 0) {
                        searchResults.innerHTML = '<li class="no-results">No locations found</li>';
                        searchResults.style.display = 'block';
                        return;
                    }
                    
                    searchResults.style.display = 'block';
                    data.results.forEach(place => {
                        const li = document.createElement('li');
                        const locationName = `${place.name}, ${place.admin1 || ''} ${place.country}`;
                        li.textContent = locationName;
                        
                        li.addEventListener('click', () => {
                            selectLocation({
                                name: locationName,
                                latitude: place.latitude,
                                longitude: place.longitude,
                                timezone: place.timezone
                            });
                            document.getElementById('locationSearchInput').value = '';
                            searchResults.innerHTML = '';
                            searchResults.style.display = 'none';
                        });
                        
                        searchResults.appendChild(li);
                    });
                })
                .catch(err => {
                    if (err.name !== 'AbortError') {
                        console.error('Location search error:', err);
                    }
                });
        }
        
        // Helper function to create smooth path from points
        function createSmoothPath(points, subdivisions) {
            if (points.length < 2) return points;
            
            const smoothPoints = [];
            for (let i = 0; i < points.length; i++) {
                const p0 = points[(i - 1 + points.length) % points.length];
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const p3 = points[(i + 2) % points.length];
                
                for (let t = 0; t < subdivisions; t++) {
                    const u = t / subdivisions;
                    const uu = u * u;
                    const uuu = uu * u;
                    
                    // Catmull-Rom spline
                    const angleVal = 
                        0.5 * (2 * p1.angle +
                        (-p0.angle + p2.angle) * u +
                        (2 * p0.angle - 5 * p1.angle + 4 * p2.angle - p3.angle) * uu +
                        (-p0.angle + 3 * p1.angle - 3 * p2.angle + p3.angle) * uuu);
                    
                    const radiusVal = 
                        0.5 * (2 * p1.radius +
                        (-p0.radius + p2.radius) * u +
                        (2 * p0.radius - 5 * p1.radius + 4 * p2.radius - p3.radius) * uu +
                        (-p0.radius + 3 * p1.radius - 3 * p2.radius + p3.radius) * uuu);
                    
                    smoothPoints.push({ angle: angleVal, radius: radiusVal });
                }
            }
            
            return smoothPoints;
        }
        
        // Helper function to render timeline
        function renderTimeline(scoresData, timelineId) {
            const timeline = document.getElementById(timelineId);
            if (!timeline) return;
            
            timeline.innerHTML = '';
            
            scoresData.forEach(score => {
                const item = document.createElement('div');
                item.className = 'timeline-item';
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'timeline-time';
                timeDiv.textContent = `${score.hour}:00`;
                item.appendChild(timeDiv);
                
                // Show enabled datasets
                Object.entries(datasets).forEach(([key, dataset]) => {
                    if (!dataset.enabled) return;
                    
                    const dataDiv = document.createElement('div');
                    dataDiv.className = 'timeline-data-item';
                    dataDiv.style.color = dataset.color;
                    
                    let value = score[key];
                    if (value !== undefined && value !== null) {
                        dataDiv.textContent = `${dataset.name}: ${value.toFixed(1)}${dataset.unit}`;
                        item.appendChild(dataDiv);
                    }
                });
                
                timeline.appendChild(item);
            });
        }
        
        // Calculate scores and values for a given day
        function calculateDayData(dayIndex) {
            if (dayIndex >= allDaysData.length) return [];
            
            const dayData = allDaysData[dayIndex];
            const scoresData = [];
            
            for (let hourOffset = 0; hourOffset < dayData.hours.length; hourOffset++) {
                const hourIndex = dayData.hours[hourOffset];
                const hourData = { hour: hourOffset };
                
                // Get time for tide calculations
                const timeString = weatherData?.hourly?.time?.[hourIndex];
                const time = timeString ? new Date(timeString) : null;
                
                // Calculate values for each dataset
                Object.entries(datasets).forEach(([key, dataset]) => {
                    let value = null;
                    
                    try {
                        if (key === 'tideHeight' && tideStation && time) {
                            value = TideHarmonic.predictTideHeight(tideStation, time);
                        } else if (key === 'tideMovement' && tideStation && time) {
                            value = TideHarmonic.calculateTideMovement(tideStation, time);
                        } else if (key === 'windSpeed' && weatherData?.hourly) {
                            value = weatherData.hourly.wind_speed_10m[hourIndex];
                        } else if (key === 'temperature' && weatherData?.hourly) {
                            value = weatherData.hourly.temperature_2m[hourIndex];
                        } else if (key === 'cloudCover' && weatherData?.hourly) {
                            value = weatherData.hourly.cloud_cover[hourIndex];
                        } else if (key === 'pressure' && weatherData?.hourly) {
                            value = weatherData.hourly.pressure_msl[hourIndex];
                        } else if (key === 'waveHeight' && marineData?.hourly) {
                            value = marineData.hourly.wave_height[hourIndex];
                        }
                        
                        if (value !== null && value !== undefined) {
                            hourData[key] = value;
                            hourData[key + 'Score'] = normalizeScore(value, dataset);
                        }
                    } catch (error) {
                        console.error(`Error calculating ${key}:`, error);
                    }
                });
                
                scoresData.push(hourData);
            }
            
            return scoresData;
        }
        
        // Draw separated rings chart
        function drawSeparatedChartForDay(dayIndex) {
            const canvas = document.getElementById('separatedCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            if (!container) return;
            const containerWidth = container.clientWidth;
            const width = containerWidth || 1000;
            const height = width * 0.6;
            
            canvas.width = width;
            canvas.height = height;
            
            const scoresData = calculateDayData(dayIndex);
            if (scoresData.length === 0) return;
            
            // Calculate layout
            const sidePadding = CHART_PADDING.side;
            const topPadding = CHART_PADDING.top;
            const bottomPadding = CHART_PADDING.bottom;
            
            const cx = width / 2;
            const cy = height - bottomPadding;
            
            const maxRadiusVertical = cy - topPadding;
            const maxRadiusHorizontal = cx - sidePadding;
            const maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            const innerRadius = maxAllowedRadius * 0.25;
            
            // Count enabled datasets
            const enabledDatasets = Object.entries(datasets).filter(([_, ds]) => ds.enabled);
            const datasetCount = enabledDatasets.length;
            
            if (datasetCount === 0) {
                ctx.clearRect(0, 0, width, height);
                return;
            }
            
            const layerHeight = (maxAllowedRadius - innerRadius) / datasetCount;
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles
            const startAngle = Math.PI;
            const angleRange = Math.PI;
            
            // Draw each dataset as a separate ring
            enabledDatasets.forEach(([key, dataset], layerIndex) => {
                const layerInnerRadius = innerRadius + layerIndex * layerHeight;
                const points = [];
                const innerPoints = [];
                
                for (let i = 0; i < scoresData.length; i++) {
                    const score = scoresData[i];
                    const t = i / (scoresData.length - 1);
                    const angle = startAngle + t * angleRange;
                    
                    const scoreValue = score[key + 'Score'] || 0;
                    const layerThickness = scoreValue * layerHeight;
                    
                    points.push({ angle, radius: layerInnerRadius + layerThickness });
                    innerPoints.push({ angle, radius: layerInnerRadius });
                }
                
                const smoothOuter = createSmoothPath(points, 10);
                const smoothInner = createSmoothPath(innerPoints, 10);
                
                // Draw filled area
                ctx.fillStyle = dataset.color + AREA_OPACITY; // 50% opacity
                ctx.beginPath();
                for (let i = 0; i < smoothOuter.length; i++) {
                    const x = cx + Math.cos(smoothOuter[i].angle) * smoothOuter[i].radius;
                    const y = cy + Math.sin(smoothOuter[i].angle) * smoothOuter[i].radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                for (let i = smoothInner.length - 1; i >= 0; i--) {
                    const x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                    const y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = dataset.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // Draw time labels
            for (let i = 0; i < scoresData.length; i++) {
                if (i % HOUR_LABEL_INTERVAL !== 0) continue;
                
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                
                const labelDist = maxAllowedRadius + 50;
                const x = cx + Math.cos(angle) * labelDist;
                const y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${scoresData[i].hour}:00`, x, y);
            }
            
            renderTimeline(scoresData, 'timeline1');
            updateLegendForChart('legend1');
            
            const date = new Date(allDaysData[dayIndex].date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Separated Rings`;
        }
        
        // Draw overlaid chart
        function drawOverlaidChartForDay(dayIndex) {
            const canvas = document.getElementById('overlaidCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            if (!container) return;
            const containerWidth = container.clientWidth;
            const width = containerWidth || 1000;
            const height = width * 0.6;
            
            canvas.width = width;
            canvas.height = height;
            
            const scoresData = calculateDayData(dayIndex);
            if (scoresData.length === 0) return;
            
            // Calculate layout
            const sidePadding = 80;
            const topPadding = 70;
            const bottomPadding = 20;
            
            const cx = width / 2;
            const cy = height - bottomPadding;
            
            const maxRadiusVertical = cy - topPadding;
            const maxRadiusHorizontal = cx - sidePadding;
            const maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            const innerRadius = maxAllowedRadius * 0.25;
            const maxHeight = maxAllowedRadius - innerRadius;
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles
            const startAngle = Math.PI;
            const angleRange = Math.PI;
            
            // Draw each dataset overlaid
            const enabledDatasets = Object.entries(datasets).filter(([_, ds]) => ds.enabled);
            
            enabledDatasets.forEach(([key, dataset]) => {
                const points = [];
                const innerPoints = [];
                
                for (let i = 0; i < scoresData.length; i++) {
                    const score = scoresData[i];
                    const t = i / (scoresData.length - 1);
                    const angle = startAngle + t * angleRange;
                    
                    const scoreValue = score[key + 'Score'] || 0;
                    const layerThickness = scoreValue * maxHeight;
                    
                    points.push({ angle, radius: innerRadius + layerThickness });
                    innerPoints.push({ angle, radius: innerRadius });
                }
                
                const smoothOuter = createSmoothPath(points, 10);
                const smoothInner = createSmoothPath(innerPoints, 10);
                
                // Draw filled area
                ctx.fillStyle = dataset.color + AREA_OPACITY; // 50% opacity
                ctx.beginPath();
                for (let i = 0; i < smoothOuter.length; i++) {
                    const x = cx + Math.cos(smoothOuter[i].angle) * smoothOuter[i].radius;
                    const y = cy + Math.sin(smoothOuter[i].angle) * smoothOuter[i].radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                for (let i = smoothInner.length - 1; i >= 0; i--) {
                    const x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                    const y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = dataset.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // Draw time labels
            for (let i = 0; i < scoresData.length; i++) {
                if (i % HOUR_LABEL_INTERVAL !== 0) continue;
                
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                
                const labelDist = maxAllowedRadius + 50;
                const x = cx + Math.cos(angle) * labelDist;
                const y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${scoresData[i].hour}:00`, x, y);
            }
            
            renderTimeline(scoresData, 'timeline2');
            updateLegendForChart('legend2');
            
            const date = new Date(allDaysData[dayIndex].date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Overlaid`;
        }
        
        // Draw stacked chart with special normalization
        function drawStackedChartForDay(dayIndex) {
            const canvas = document.getElementById('stackedCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            if (!container) return;
            const containerWidth = container.clientWidth;
            const width = containerWidth || 1000;
            const height = width * 0.6;
            
            canvas.width = width;
            canvas.height = height;
            
            const scoresData = calculateDayData(dayIndex);
            if (scoresData.length === 0) return;
            
            // Calculate layout
            const sidePadding = 80;
            const topPadding = 70;
            const bottomPadding = 20;
            
            const cx = width / 2;
            const cy = height - bottomPadding;
            
            const maxRadiusVertical = cy - topPadding;
            const maxRadiusHorizontal = cx - sidePadding;
            const maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            const innerRadius = maxAllowedRadius * 0.25;
            const maxHeight = maxAllowedRadius - innerRadius;
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles
            const startAngle = Math.PI;
            const angleRange = Math.PI;
            
            // Count enabled datasets for normalization
            const enabledDatasets = Object.entries(datasets).filter(([_, ds]) => ds.enabled);
            const datasetCount = enabledDatasets.length;
            
            if (datasetCount === 0) return;
            
            // Draw stacked datasets with normalization
            let currentLayerPoints = [];
            
            // Initialize base layer (inner circle)
            for (let i = 0; i < scoresData.length; i++) {
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                currentLayerPoints.push({ angle, radius: innerRadius });
            }
            
            enabledDatasets.forEach(([key, dataset]) => {
                const nextLayerPoints = [];
                
                for (let i = 0; i < scoresData.length; i++) {
                    const score = scoresData[i];
                    const scoreValue = score[key + 'Score'] || 0;
                    
                    // Divide by dataset count for special normalization
                    const normalizedScore = scoreValue / datasetCount;
                    const layerThickness = normalizedScore * maxHeight;
                    
                    const currentRadius = currentLayerPoints[i].radius;
                    nextLayerPoints.push({ 
                        angle: currentLayerPoints[i].angle, 
                        radius: currentRadius + layerThickness 
                    });
                }
                
                const smoothCurrent = createSmoothPath(currentLayerPoints, 10);
                const smoothNext = createSmoothPath(nextLayerPoints, 10);
                
                // Draw filled area
                ctx.fillStyle = dataset.color + AREA_OPACITY; // 50% opacity
                ctx.beginPath();
                for (let i = 0; i < smoothNext.length; i++) {
                    const x = cx + Math.cos(smoothNext[i].angle) * smoothNext[i].radius;
                    const y = cy + Math.sin(smoothNext[i].angle) * smoothNext[i].radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                for (let i = smoothCurrent.length - 1; i >= 0; i--) {
                    const x = cx + Math.cos(smoothCurrent[i].angle) * smoothCurrent[i].radius;
                    const y = cy + Math.sin(smoothCurrent[i].angle) * smoothCurrent[i].radius;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = dataset.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Update current layer for next iteration
                currentLayerPoints = nextLayerPoints;
            });
            
            // Draw time labels
            for (let i = 0; i < scoresData.length; i++) {
                if (i % HOUR_LABEL_INTERVAL !== 0) continue;
                
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                
                const labelDist = maxAllowedRadius + 50;
                const x = cx + Math.cos(angle) * labelDist;
                const y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${scoresData[i].hour}:00`, x, y);
            }
            
            renderTimeline(scoresData, 'timeline3');
            updateLegendForChart('legend3');
            
            const date = new Date(allDaysData[dayIndex].date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Stacked (Normalized by Dataset Count)`;
        }
        
        // Draw hourly rating chart
        function drawHourlyRatingChartForDay(dayIndex) {
            const canvas = document.getElementById('hourlyRatingCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            if (!container) return;
            const containerWidth = container.clientWidth;
            const width = containerWidth || 1000;
            const height = width * 0.6;
            
            canvas.width = width;
            canvas.height = height;
            
            const scoresData = calculateDayData(dayIndex);
            if (scoresData.length === 0) return;
            
            // Calculate layout
            const sidePadding = 80;
            const topPadding = 70;
            const bottomPadding = 20;
            
            const cx = width / 2;
            const cy = height - bottomPadding;
            
            const maxRadiusVertical = cy - topPadding;
            const maxRadiusHorizontal = cx - sidePadding;
            const maxAllowedRadius = Math.min(maxRadiusVertical, maxRadiusHorizontal);
            
            const innerRadius = maxAllowedRadius * 0.25;
            const maxHeight = maxAllowedRadius - innerRadius;
            
            ctx.clearRect(0, 0, width, height);
            
            // Calculate angles
            const startAngle = Math.PI;
            const angleRange = Math.PI;
            
            // Calculate combined rating for each hour
            const ratingPoints = [];
            const innerPoints = [];
            
            for (let i = 0; i < scoresData.length; i++) {
                const score = scoresData[i];
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                
                // Average all enabled dataset scores
                let totalScore = 0;
                let count = 0;
                
                Object.entries(datasets).forEach(([key, dataset]) => {
                    if (!dataset.enabled) return;
                    const scoreValue = score[key + 'Score'];
                    if (scoreValue !== undefined && scoreValue !== null) {
                        totalScore += scoreValue;
                        count++;
                    }
                });
                
                const avgScore = count > 0 ? totalScore / count : 0;
                const layerThickness = avgScore * maxHeight;
                
                ratingPoints.push({ angle, radius: innerRadius + layerThickness });
                innerPoints.push({ angle, radius: innerRadius });
            }
            
            const smoothRating = createSmoothPath(ratingPoints, 10);
            const smoothInner = createSmoothPath(innerPoints, 10);
            
            // Draw filled area with gradient
            const gradient = ctx.createLinearGradient(0, cy - maxAllowedRadius, 0, cy);
            gradient.addColorStop(0, 'rgba(118, 75, 162, 0.8)');
            gradient.addColorStop(1, 'rgba(102, 126, 234, 0.6)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            for (let i = 0; i < smoothRating.length; i++) {
                const x = cx + Math.cos(smoothRating[i].angle) * smoothRating[i].radius;
                const y = cy + Math.sin(smoothRating[i].angle) * smoothRating[i].radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            for (let i = smoothInner.length - 1; i >= 0; i--) {
                const x = cx + Math.cos(smoothInner[i].angle) * smoothInner[i].radius;
                const y = cy + Math.sin(smoothInner[i].angle) * smoothInner[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            // Draw border
            ctx.strokeStyle = 'rgba(102, 126, 234, 1.0)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw time labels
            for (let i = 0; i < scoresData.length; i++) {
                if (i % HOUR_LABEL_INTERVAL !== 0) continue;
                
                const t = i / (scoresData.length - 1);
                const angle = startAngle + t * angleRange;
                
                const labelDist = maxAllowedRadius + 50;
                const x = cx + Math.cos(angle) * labelDist;
                const y = cy + Math.sin(angle) * labelDist;
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${scoresData[i].hour}:00`, x, y);
            }
            
            updateLegendForChart('legend4');
            
            const date = new Date(allDaysData[dayIndex].date + 'T00:00:00');
            document.getElementById('locationTitle').textContent = currentLocation.name;
            document.getElementById('dateSubtitle').textContent = `${date.toLocaleDateString()} - Hourly Rating`;
        }
        
        // Update legend for specific chart
        function updateLegendForChart(legendId) {
            const legendContainer = document.getElementById(legendId);
            if (!legendContainer) return;
            
            legendContainer.innerHTML = '';
            
            Object.entries(datasets).forEach(([key, dataset]) => {
                if (!dataset.enabled) return;
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${dataset.color};"></div>
                    <span><strong>${dataset.name}</strong></span>
                `;
                legendContainer.appendChild(item);
            });
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
