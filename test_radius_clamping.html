<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Radius Clamping Fix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .test-section {
            margin: 30px 0;
        }
        h2 {
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        canvas {
            border: 1px solid #ddd;
            margin: 10px 0;
        }
        .description {
            background: #f9f9f9;
            padding: 15px;
            border-left: 4px solid #667eea;
            margin: 10px 0;
        }
        .success {
            color: #10b981;
            font-weight: bold;
        }
        .issue {
            color: #ef4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Radius Clamping Fix Demonstration</h1>
        
        <div class="test-section">
            <h2>Test 1: Without Clamping (Before Fix)</h2>
            <div class="description">
                <p><span class="issue">❌ Issue:</span> Catmull-Rom spline can overshoot, causing radius to go below innerRadius.</p>
                <p>Notice how the smoothed path (blue) dips inward past the inner circle (red dashed line).</p>
            </div>
            <canvas id="beforeCanvas" width="600" height="400"></canvas>
        </div>
        
        <div class="test-section">
            <h2>Test 2: With Clamping (After Fix)</h2>
            <div class="description">
                <p><span class="success">✓ Fixed:</span> Radius values are clamped to never go below innerRadius.</p>
                <p>The smoothed path (green) respects the minimum radius constraint.</p>
            </div>
            <canvas id="afterCanvas" width="600" height="400"></canvas>
        </div>
        
        <div class="test-section">
            <h2>Test 3: Radial Chart Simulation</h2>
            <div class="description">
                <p>Simulates a radial chart with data that would cause overshoot without clamping.</p>
                <p>Left: Before fix (notice inward collapse). Right: After fix (proper visualization).</p>
            </div>
            <canvas id="comparisonCanvas" width="1000" height="500"></canvas>
        </div>
    </div>

    <script>
        // Function without clamping (original)
        function createSmoothPathOld(points, subdivisions) {
            if (points.length < 2) return points;
            
            const smoothPoints = [];
            for (let i = 0; i < points.length; i++) {
                const p0 = points[(i - 1 + points.length) % points.length];
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const p3 = points[(i + 2) % points.length];
                
                for (let t = 0; t < subdivisions; t++) {
                    const u = t / subdivisions;
                    const uu = u * u;
                    const uuu = uu * u;
                    
                    const angleVal = 
                        0.5 * (2 * p1.angle +
                        (-p0.angle + p2.angle) * u +
                        (2 * p0.angle - 5 * p1.angle + 4 * p2.angle - p3.angle) * uu +
                        (-p0.angle + 3 * p1.angle - 3 * p2.angle + p3.angle) * uuu);
                    
                    const radiusVal = 
                        0.5 * (2 * p1.radius +
                        (-p0.radius + p2.radius) * u +
                        (2 * p0.radius - 5 * p1.radius + 4 * p2.radius - p3.radius) * uu +
                        (-p0.radius + 3 * p1.radius - 3 * p2.radius + p3.radius) * uuu);
                    
                    smoothPoints.push({ angle: angleVal, radius: radiusVal });
                }
            }
            
            return smoothPoints;
        }

        // Function with clamping (fixed)
        function createSmoothPathNew(points, subdivisions, minRadius = null) {
            if (points.length < 2) return points;
            
            const smoothPoints = [];
            for (let i = 0; i < points.length; i++) {
                const p0 = points[(i - 1 + points.length) % points.length];
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const p3 = points[(i + 2) % points.length];
                
                for (let t = 0; t < subdivisions; t++) {
                    const u = t / subdivisions;
                    const uu = u * u;
                    const uuu = uu * u;
                    
                    const angleVal = 
                        0.5 * (2 * p1.angle +
                        (-p0.angle + p2.angle) * u +
                        (2 * p0.angle - 5 * p1.angle + 4 * p2.angle - p3.angle) * uu +
                        (-p0.angle + 3 * p1.angle - 3 * p2.angle + p3.angle) * uuu);
                    
                    let radiusVal = 
                        0.5 * (2 * p1.radius +
                        (-p0.radius + p2.radius) * u +
                        (2 * p0.radius - 5 * p1.radius + 4 * p2.radius - p3.radius) * uu +
                        (-p0.radius + 3 * p1.radius - 3 * p2.radius + p3.radius) * uuu);
                    
                    // Clamp radius to prevent Catmull-Rom overshoot below minimum
                    if (minRadius !== null) {
                        radiusVal = Math.max(minRadius, radiusVal);
                    }
                    
                    smoothPoints.push({ angle: angleVal, radius: radiusVal });
                }
            }
            
            return smoothPoints;
        }

        // Test 1: Before fix
        function testBefore() {
            const canvas = document.getElementById('beforeCanvas');
            const ctx = canvas.getContext('2d');
            const cx = 300, cy = 200;
            const innerRadius = 50;
            
            // Create test data with sharp changes that will cause overshoot
            const points = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                // Alternate between high and low values to induce overshoot
                const radius = innerRadius + (i % 2 === 0 ? 100 : 20);
                points.push({ angle, radius });
            }
            
            const smoothed = createSmoothPathOld(points, 10);
            
            // Draw inner radius circle (minimum allowed)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw control points
            ctx.fillStyle = '#999';
            points.forEach(p => {
                const x = cx + Math.cos(p.angle) * p.radius;
                const y = cy + Math.sin(p.angle) * p.radius;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw smoothed path
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            smoothed.forEach((p, i) => {
                const x = cx + Math.cos(p.angle) * p.radius;
                const y = cy + Math.sin(p.angle) * p.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.stroke();
            
            // Check for violations
            let violations = 0;
            smoothed.forEach(p => {
                if (p.radius < innerRadius) violations++;
            });
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`Violations: ${violations} points below minimum radius`, 10, 30);
        }

        // Test 2: After fix
        function testAfter() {
            const canvas = document.getElementById('afterCanvas');
            const ctx = canvas.getContext('2d');
            const cx = 300, cy = 200;
            const innerRadius = 50;
            
            // Same test data
            const points = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = innerRadius + (i % 2 === 0 ? 100 : 20);
                points.push({ angle, radius });
            }
            
            const smoothed = createSmoothPathNew(points, 10, innerRadius);
            
            // Draw inner radius circle
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw control points
            ctx.fillStyle = '#999';
            points.forEach(p => {
                const x = cx + Math.cos(p.angle) * p.radius;
                const y = cy + Math.sin(p.angle) * p.radius;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw smoothed path
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            ctx.beginPath();
            smoothed.forEach((p, i) => {
                const x = cx + Math.cos(p.angle) * p.radius;
                const y = cy + Math.sin(p.angle) * p.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.stroke();
            
            // Check for violations
            let violations = 0;
            smoothed.forEach(p => {
                if (p.radius < innerRadius) violations++;
            });
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`Violations: ${violations} points below minimum radius ✓`, 10, 30);
        }

        // Test 3: Radial chart comparison
        function testComparison() {
            const canvas = document.getElementById('comparisonCanvas');
            const ctx = canvas.getContext('2d');
            
            // Simulate wave height data scenario from problem statement
            const innerRadius = 80;
            const layerHeight = 120;
            
            // Create data where all values are in ideal range (should show full)
            const scoreValues = [];
            for (let i = 0; i < 24; i++) {
                scoreValues.push(0.8 + Math.random() * 0.2); // 0.8-1.0 (in ideal range)
            }
            
            // Before fix (left side)
            const cx1 = 250, cy1 = 250;
            const points1 = [];
            const innerPoints1 = [];
            for (let i = 0; i < scoreValues.length; i++) {
                const angle = Math.PI + (i / (scoreValues.length - 1)) * Math.PI;
                points1.push({ angle, radius: innerRadius + scoreValues[i] * layerHeight });
                innerPoints1.push({ angle, radius: innerRadius });
            }
            
            const smoothOuter1 = createSmoothPathOld(points1, 10);
            const smoothInner1 = createSmoothPathOld(innerPoints1, 10);
            
            // Draw before
            ctx.fillStyle = 'rgba(102, 126, 234, 0.3)';
            ctx.beginPath();
            smoothOuter1.forEach((p, i) => {
                const x = cx1 + Math.cos(p.angle) * p.radius;
                const y = cy1 + Math.sin(p.angle) * p.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            for (let i = smoothInner1.length - 1; i >= 0; i--) {
                const x = cx1 + Math.cos(smoothInner1[i].angle) * smoothInner1[i].radius;
                const y = cy1 + Math.sin(smoothInner1[i].angle) * smoothInner1[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(102, 126, 234, 1.0)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // After fix (right side)
            const cx2 = 750, cy2 = 250;
            const points2 = [];
            const innerPoints2 = [];
            for (let i = 0; i < scoreValues.length; i++) {
                const angle = Math.PI + (i / (scoreValues.length - 1)) * Math.PI;
                points2.push({ angle, radius: innerRadius + scoreValues[i] * layerHeight });
                innerPoints2.push({ angle, radius: innerRadius });
            }
            
            const smoothOuter2 = createSmoothPathNew(points2, 10, innerRadius);
            const smoothInner2 = createSmoothPathNew(innerPoints2, 10, innerRadius);
            
            // Draw after
            ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
            ctx.beginPath();
            smoothOuter2.forEach((p, i) => {
                const x = cx2 + Math.cos(p.angle) * p.radius;
                const y = cy2 + Math.sin(p.angle) * p.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            for (let i = smoothInner2.length - 1; i >= 0; i--) {
                const x = cx2 + Math.cos(smoothInner2[i].angle) * smoothInner2[i].radius;
                const y = cy2 + Math.sin(smoothInner2[i].angle) * smoothInner2[i].radius;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(16, 185, 129, 1.0)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BEFORE FIX', cx1, 450);
            ctx.fillText('(Notice inward collapse)', cx1, 470);
            ctx.fillText('AFTER FIX', cx2, 450);
            ctx.fillText('(Proper visualization)', cx2, 470);
        }

        // Run tests
        testBefore();
        testAfter();
        testComparison();
    </script>
</body>
</html>
